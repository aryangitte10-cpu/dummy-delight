datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Enum Definitions
enum EventType {
  WORKSHOP
  TRAINING
  SEMINAR
  CONFERENCE
  NETWORKING
  TEAM_BUILDING
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
}


// User Model
model User {
  id                String              @id @default(cuid())
  name              String
  email             String              @unique
  profileImage      String?
  registrations     EventRegistration[]
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([email])
  @@index([name])
}

// Coach Model
model Coach {
  id            String              @id @default(cuid())
  name          String
  email         String              @unique
  bio           String?
  profileImage  String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  expertise     String[]?
  @@index([name])
  @@index([email])
}


// Event Model
model Event {
  id            String          @id @default(cuid())
  title         String
  description   String
  eventTypes    EventType[]
  
  // Relationships
  coaches       Coach[]
  organizerId   String
  photos        EventPhoto[]
  timeSlots     TimeSlot[]
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([createdAt(sort: Desc)])
  @@index(eventTypes)
}


// Event Photos Model
model EventPhoto {
  id        String   @id @default(cuid())
  event     Event    @relation(fields: [eventId], references: [id])
  eventId   String
  url       String
  caption   String?
  
  @@index([eventId])
}

// Time Slot Model
model TimeSlot {
  id            String           @id @default(cuid())
  event         Event            @relation(fields: [eventId], references: [id])
  eventId       String
  
  startTime     DateTime
  endTime       DateTime
  totalSeats    Int
  availableSeats Int
  isAvailable   Boolean          @default(true)
  
  // Registrations for this time slot
  registrations EventRegistration[]
  
  @@index([eventId])
  @@index([startTime, endTime])
  @@index([availableSeats])
  @@index([isAvailable])
  @@index([startTime, endTime, availableSeats, isAvailable])
}

// Event Registration Model
model EventRegistration {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id])
  userId        String
  timeSlot      TimeSlot @relation(fields: [timeSlotId], references: [id])
  timeSlotId    String
  
  registeredAt  DateTime @default(now())
  eventInvitation EventInvitation[]
  @@index([userId])
  @@index([timeSlotId])
  @@index([registeredAt(sort: Desc)])
}

// Event Invitation Model
model EventInvitation {
  id            String   @id @default(cuid())
  event         Event    @relation(fields: [eventId], references: [id])
  eventId       String
  invitedEmail  String
  sender        User     @relation("SentInvitations", fields: [senderId], references: [id])
  senderId      String
  
  status        InvitationStatus @default(PENDING)
  invitedAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([eventId])
  @@index([invitedEmail])
  @@index([senderId])
  @@index([status])
  @@index([invitedAt(sort: Desc)])
}
```

Key Improvements and Features:

1. **Comprehensive Recurrence Modeling**:
   - Separate `RecurrencePattern` model
   - Supports complex recurring event patterns
   - Flexible day and interval specifications

2. **Enhanced User and Coach Models**:
   - Added profile images
   - Comprehensive relationship tracking

3. **Flexible Event Creation**:
   - Multiple coaches per event
   - Event type multiplicity
   - Detailed time slot management

4. **Optimized Indexing**:
   - Strategically placed indexes for performance
   - Support for complex queries

5. **Invitation and Registration System**:
   - Detailed invitation tracking
   - Flexible registration process

Example Queries to Illustrate Capabilities:

```typescript
// Find events with specific types and availability
const events = await prisma.event.findMany({
  where: {
    eventTypes: { hasSome: ['WORKSHOP', 'TRAINING'] },
    timeSlots: {
      some: {
        availableSeats: { gte: 5 },
        startTime: {
          gte: new Date(), // From now
          lt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // Next 30 days
        }
      }
    }
  },
  include: {
    coaches: true,
    timeSlots: {
      where: { availableSeats: { gt: 0 } }
    }
  }
});

// Create a recurring weekly event
const recurringEvent = await prisma.event.create({
  data: {
    title: "Weekly Team Training",
    description: "Regular team skill development session",
    eventTypes: ['TRAINING'],
    organizer: { connect: { id: organizerId } },
    coaches: { connect: [{ id: coachId }] },
    recurrencePattern: {
      create: {
        frequency: 'WEEKLY',
        interval: 1,
        daysOfWeek: [2, 4], // Tuesdays and Thursdays
        startDate: new Date(),
        endDate: new Date(Date.now() + 180 * 24 * 60 * 60 * 1000), // 6 months
        maxOccurrences: 24
      }
    },
    timeSlots: {
      create: {
        startTime: new Date(),
        endTime: new Date(Date.now() + 2 * 60 * 60 * 1000), // 2-hour slot
        totalSeats: 20,
        availableSeats: 20
      }
    }
  }
});
```

Potential Enhancements:
- Add more complex filtering options
- Implement advanced scheduling logic
- Create more detailed availability rules

Would you like me to elaborate on any specific aspect of the schema or its capabilities?